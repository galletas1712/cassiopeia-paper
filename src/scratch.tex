$$

    Suppose the dealer wants to share a secret bit string $s$ which can only be revealed after block number $T$.
    The dealer first appends a random bit string $r$ of length $\lambda$ to $s$, where $\lambda$ is a security parameter.
    From this augmented $s$, the dealer computes $y = H(s)$ where $H$ is a random oracle, and $c, \pi$ which are the ciphertext and the proof generated by PVSS respectively.
    The dealer sends a commitment for $c$ and $T$ to the smart contract by calling $\textsf{commitToShareSecret}(H(c, T))$.
    After waiting $\Delta$ blocks for the transaction to be confirmed, he then calls $\textsf{shareSecret}(c, \pi, T, y)$ to post the ciphertext and all related public values to the smart contract.

    Upon the dealer calling $\textsf{shareSecret}(c, \pi, T, y)$, the smart contract checks that the following properties hold:
    \begin{itemize}
            \item $H(c, T)$ has been sent to the contract via \textsf{commitToShareSecret} at least $\Delta$ blocks prior.
    \end{itemize}

    Wait what if we submit to different smart contracts? Whether or not this smart contract has seen y or not doesn't actually matter does it?
    Let $y = H(s \concat T)$.
    Then we only need a SNARK to check that the preimage of $y$ is consistent with $c$ and $T$.
    We think of security against front running and malleability as an adversary can intercept the message and change it however they want before submission.
    Changing what secret $c$ encodes to or $T$ would mean $y$ needs to be changed randomly.
    If the adversary changes $c$ such that $c$ encodes the same secret, nothing actually happens to the safety of the protcol as long as $T$ cannot be changed.
    Can we make the SNARK less costly?

    We can also try generating Schnorr signatures for $H(c \concat T)$ by using the secret as the signing key itself.
    We need to prove that the decryptions of $c$ correspond to the dlog of the public key
    
    \begin{theorem}
    For all secrets $s$ and $(c, T, y, \pi)$ such that $\textsf{shareSecret}(c, T, y, \pi)$ does not revert, a PPT adversary $\mathcal{A}$ cannot produce any $(c', T', y', \pi')$ such that $c' \neq c$ or $T' \neq T$, the secret $s'$ that $c'$ encodes is related to $s$ and $\textsf{shareSecret}(c', T', y', \pi')$ does not revert.
    \end{theorem}
    \begin{proof}
    Assume for the sake of contradiction that $\mathcal{A}$ can produce such a $(c', T', y', \pi')$.
    Since $H$ is a random oracle, for any choice of $c', T'$ such that $c \neq c'$ or $T \neq T'$, $\mathcal{A}$ must provide $s'$ to generate a $y' \neq y$ and a proof $\pi'$ that passes the SNARK verification check.
    This means that $\mathcal{A}$ must be able to generate $c'$ from knowledge of $s'$.
    Since $s'$ and $s$ are related, $\mathcal{A}$ can recover $s$ from knowledge of $s'$, which is a contradiction since $s$ is never revealed to $\mathcal{A}$.
    
    \end{proof}
    
    % contract Cassiopeia {
    %     pks
    %     secrets = 0
        
    %     constructor(_pks) {
    %         pks = _pks;
    %     }
        
    %     deal(_encrypted-shares, T, t) payable {
    %         id = secrets++;
    %         encrypted-shares[id] = _encrypted-shares
    %         PVSS.deal-verify(encrypted-shares, pks);
            
    %         for ((share, proof) in encrypted-shares) {
    %             // check correct encryption with pks[i] 
    %         }
    %         returns id;
    %     }
        
    %     submit-share(share, proof, id) { // after time() >= t
    %         // pay out to person submitting share
    %         PVSS.verify-share(share, proof, encrypted-shares[id]);
    %     }
        
    %     recover(id) { // only works after time() >= t + grace
    %         // ...
    %         return plaintext
    %     }
    % }

    %     \begin{algorithm}[H]
%     \caption{Cassiopeia Smart Contract}
%         \begin{algorithmic}[1]
%             \Contract{Cassiopeia}
%                 \Let{n}{\bot}
%                 \Let{t}{\bot}
%                 \Let{T'}{\bot}
%                 \Let{pks}{\emptyset}
%                 \Let{\textsf{secrets}}{\emptyset}
%                 \Let{\textsf{numSecrets}}{0}
%                 
%                 \Function{\sf construct}{$\overline{n}, \overline{t}, \overline{T'}, \overline{pks}$}
%                     \Let{n}{\overline{n}}
%                     \Let{t}{\overline{t}}
%                     \Let{T'}{\overline{T'}}
%                     \Let{pks}{\overline{pks}}
%                 \EndFunction
%                 
%                 \Function{\sf shareSecret}{$c, \pi, T, y, \sigma$} \textbf{payable}
%                     \State require($\textsf{Vrfy}_y(H(c \concat T), \sigma)$)
%                     \State $\textsf{PVSS.verifyDistribution}(c, \pi)$
%                     \State $\textsf{id} \gets \textsf{numSecrets}$
%                     \State $\textsf{secrets}[\textsf{id}].T \gets T$
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{encryptedShares} \gets c$
%                     \State $\textsf{numSecrets} \gets \textsf{numSecrets} + 1$
%                     \State \Return $\textsf{id}$
%                 \EndFunction
%                 
%                 \Function{\sf claimSecret}{\sf id}
%                     \State require($\textsf{block.number} \geq \textsf{secrets}[\textsf{id}].T$)
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{gracePeriod} \gets \textsf{block.number} + T'$
%                 \EndFunction
%                 
%                 \Function{\sf submitShare}{$s, \pi, i, \textsf{id}$}
%                 % Payout here
%                     \State require($\textsf{secrets}[\textsf{id}].T \leq \textsf{block.number} < \textsf{secrets}[\textsf{id}].\textsf{gracePeriod}$)
%                     \State $\textsf{PVSS.verifyShare}(\textsf{secrets}[\textsf{id}].\textsf{encryptedShares}, s, \pi, i)$
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{postedShares}.\textsf{append}(s)$
%                 \EndFunction
%                 
%                 \Function{\sf recoverSecret}{\sf id}
%                     \State require($\textsf{block.number} \geq \textsf{secrets}[\textsf{id}].\textsf{gracePeriod}$)
%                     \State \Return $\textsf{PVSS.reconstruct}(\textsf{postedShares}[:t])$
%                 \EndFunction
%             \EndContract
%         \end{algorithmic}
%     \end{algorithm}

% \textbf{Outstanding issues.}
% \begin{enumerate}
% \item Malleability of secret sharing
%       Assumptions: (need to get rid of)
%       a) You cannot create (c', pi') that correspond to a "related" secret s' != s <-- OK
%         Random oracle H(r || s), y. If you change y, you change everything (r, s)
%       b) You cannot create (c', pi') s.t. c' != c or pi != pi', s.t. they encode the same secret as (c, pi), s' = s <-- OK
%         CHeck that y corresponds to c, y not in seen, and delay (to prevent front running, adversary is the ham)
% \item Front-running -- OK
%     Other reason for delay is adversary might take the shareSecret(...) and replay it
% \item Semantic security -- OK
%     Commit-reveal
%     Secret sharing
%     y commitment
%     All computationally hiding
% \item Low secret entropy problem (guessing) -- OK
%     Add randomness to secret
% \item Replayability -- OK
% \end{enumerate}

%     \begin{algorithm}[H]
%     \caption{Cassiopeia Smart Contract}
%         \begin{algorithmic}[1]
%             \Contract{Cassiopeia}
%                 \Let{n}{\bot}
%                 \Let{t}{\bot}
%                 \Let{T'}{\bot}
%                 \Let{pks}{\emptyset}
%                 \Let{\textsf{secrets}}{\emptyset}
%                 \Let{\textsf{numSecrets}}{0}
%                 
%                 \Function{\sf construct}{$\overline{n}, \overline{t}, \overline{T'}, \overline{pks}$}
%                     \Let{n}{\overline{n}}
%                     \Let{t}{\overline{t}}
%                     \Let{T'}{\overline{T'}}
%                     \Let{pks}{\overline{pks}}
%                 \EndFunction
%                 
%                 \Function{\sf shareSecret}{$c, \pi, T, y, \sigma$} \textbf{payable}
%                     \State require($\textsf{Vrfy}_y(H(c \concat T), \sigma)$)
%                     \State $\textsf{PVSS.verifyDistribution}(c, \pi)$
%                     \State $\textsf{id} \gets \textsf{numSecrets}$
%                     \State $\textsf{secrets}[\textsf{id}].T \gets T$
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{encryptedShares} \gets c$
%                     \State $\textsf{numSecrets} \gets \textsf{numSecrets} + 1$
%                     \State \Return $\textsf{id}$
%                 \EndFunction
%                 
%                 \Function{\sf claimSecret}{\sf id}
%                     \State require($\textsf{block.number} \geq \textsf{secrets}[\textsf{id}].T$)
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{gracePeriod} \gets \textsf{block.number} + T'$
%                 \EndFunction
%                 
%                 \Function{\sf submitShare}{$s, \pi, i, \textsf{id}$}
%                 % Payout here
%                     \State require($\textsf{secrets}[\textsf{id}].T \leq \textsf{block.number} < \textsf{secrets}[\textsf{id}].\textsf{gracePeriod}$)
%                     \State $\textsf{PVSS.verifyShare}(\textsf{secrets}[\textsf{id}].\textsf{encryptedShares}, s, \pi, i)$
%                     \State $\textsf{secrets}[\textsf{id}].\textsf{postedShares}.\textsf{append}(s)$
%                 \EndFunction
%                 
%                 \Function{\sf recoverSecret}{\sf id}
%                     \State require($\textsf{block.number} \geq \textsf{secrets}[\textsf{id}].\textsf{gracePeriod}$)
%                     \State \Return $\textsf{PVSS.reconstruct}(\textsf{postedShares}[:t])$
%                 \EndFunction
%             \EndContract
%         \end{algorithmic}
%     \end{algorithm}

% \textbf{Outstanding issues.}
% \begin{enumerate}
% \item Malleability of secret sharing
%       Assumptions: (need to get rid of)
%       a) You cannot create (c', pi') that correspond to a "related" secret s' != s <-- OK
%         Random oracle H(r || s), y. If you change y, you change everything (r, s)
%       b) You cannot create (c', pi') s.t. c' != c or pi != pi', s.t. they encode the same secret as (c, pi), s' = s <-- OK
%         CHeck that y corresponds to c, y not in seen, and delay (to prevent front running, adversary is the ham)
% \item Front-running -- OK
%     Other reason for delay is adversary might take the shareSecret(...) and replay it
% \item Semantic security -- OK
%     Commit-reveal
%     Secret sharing
%     y commitment
%     All computationally hiding
% \item Low secret entropy problem (guessing) -- OK
%     Add randomness to secret
% \item Replayability -- OK
% \end{enumerate}