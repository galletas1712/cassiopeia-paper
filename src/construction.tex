\section{Construction}\label{construction:without_incentives}
The Cassiopeia smart contract is instantiated for a fixed committee with known public keys of size $n$, and a fixed threshold $t$.
Suppose the dealer wants to perform Social Witness Encryption with public witness security on a message $m$.
First, the dealer chooses a relation $\mathcal{R}$ and a corresponding instance $x$.
% In practice, the pair $(\mathcal{R}, x)$ could be encoded as a smart contract function that accepts $w$ and returns 1 if $(x, w) \in \mathcal{R}$ and 0 otherwise.
Then, the dealer generates a random bit string $s$ that can be simultaneously used as the secret in a PVSS scheme and the key of a symmetric encryption scheme. % Security of symmetric encryption scheme?
The dealer runs \textsf{PVSS.genDist}$(s)$ to generate the PVSS ciphertext $c$, which contains the encrypted secret shares for each participant $\hat{s}$, along with a proof $\pi_D$ that the generated encrypted secret shares are consistent with one another.
Using the symmetric encryption scheme, the dealer encrypts $m$ with key $s$ to produce $\hat{c} = Enc_s(m)$.
The dealer calls the smart contract function \textsf{Cassiopeia.encrypt} to register the ciphertext and instance on chain.
The contract checks whether the proof $\pi_D$ is valid, and if so, makes the encrypted secret shares available to the committee members. 
A unique identifier for the secret $id$ is returned.
Subsequently, $\hat{c}$ is dispersed publicly, either off-chain to optimize gas costs or on-chain for data availability.

\begin{algorithm}[H]
\caption{Dealer interaction with Cassiopeia}
\label{dealer_alg_no_incentives}
    \begin{algorithmic}[1]
        \On{$\textsf{WE.Enc}_{\mathcal{R}}(1^{\lambda}, x, m)$}
            \State $s \getsrandomly \{0,1\}^{\lambda}$
            \State $\hat{c} \gets Enc_s(m)$
            \State $c \gets \textsf{PVSS.genDist}(s, \textsf{Cassiopeia}.pks)$
            \State $y \gets H(s \concat c \concat \mathcal{R} \concat x)$
            \State $\pi \gets P(\sigma, (c, \mathcal{R}, x, y, \textsf{Cassiopeia}.pks), s)$
            \State $id \gets \textsf{Cassiopeia.encrypt}(c, \pi, \mathcal{R}, x, y)$
            \State $\textsf{disperse}(id, \hat{c})$ % IMPORTANT: dealer MUST be honest for secret recovery right?
        \EndOn
    \end{algorithmic}
\end{algorithm}

Anybody who obtains a valid witness $w$ can call the smart contract function \textsf{claim} to start decryption.
The smart contract checks that $w$ is indeed a valid witness such that $(x, w) \in \mathcal{R}$.
If so, it enables committee members to submit their (decrypted) shares by setting a flag $M_{id}$ that indicates secret with identifier $id$ has been claimed.
To submit their share, a committee member $i$ first decrypts their encrypted share $\hat{s}_i$ given by the dealer using \textsf{PVSS.decrypt}.
This produces a decryption $s'_i$ and a proof $\pi$ that $s'_i$ is a valid decryption, i.e. $s'_i = s_i$.
The committee member then submits the share by calling the smart contract function \textsf{submitShare}, which verifies the proof and stores $s'_i$ in the set of decrypted shares $S_{id}$ inside the contract.
Committee members should submit their share within $\Delta$ blocks of the valid call to \textsf{claim}, where $\Delta$ is a public parameter.

\begin{algorithm}[H]
    \caption{Committee member interaction with Cassiopeia}
\label{committee_member_alg_no_incentives}
    \begin{algorithmic}[1]
        \Let{sk}{\text{own secret key}}
        \Let{i}{\text{index of own public key in \textsf{Cassiopeia}.$pks$}}
        \On{$\textsf{Cassiopeia.claimSecret}(id)$}
            \State $(\hat{s}, \pi_D) \gets \textsf{Cassiopeia}.C_{id}.c$
            \State $(s'_i, \pi) \gets \textsf{PVSS.decrypt}(\hat{s}_i, sk)$
            \State $\textsf{Cassiopeia.submitShare}(s'_i, \pi, id, i)$
        \EndOn
    \end{algorithmic}
\end{algorithm}

Once $|S_{id}| \geq t$, anyone can reconstruct the secret $s$ using \textsf{PVSS.reconstruct}.
To obtain the original message, $\hat{c}$ is fetched from public storage and decrypted using $s$ as the key to produce $m = Dec_s(\hat{c})$.

However, this protocol has a malleability attack.
Concretely, let $x'$ be an instance $x'$ of possibly another relation $\mathcal{R}'$ for which the adversary already knows a valid witness $w'$.
The adversary can act as a malicious dealer, calling \textsf{encrypt} with $c$ and $x'$ instead of $x$, then call \textsf{claim} with $w'$ to start decryption right away.
Therefore, the adversary can bypass the requirement of finding a valid witness $w$ for $x$ to decrypt the secret encoded by $c$.

To mitigate this issue, we ask the dealer to provide a proof in zero knowledge that he knows $s$ and he intends to encrypt $s$ with the instance $x$.
In particular, the dealer generates a commitment to the secret and ciphertext, tying it to $\mathcal{R}$ and $x$ by computing $y = H(s \concat c \concat \mathcal{R} \concat x)$, where $H$ is a random oracle.
The dealer then generates a zkSNARK proof of knowledge of $s$ such that if the encrypted shares were decrypted and recombined, the result would be $s$, and that $y = H(s \concat c \concat \mathcal{R} \concat x)$.
More formally, the proof $\pi = P(\sigma, (c, \mathcal{R}, x, y, \textsf{Cassiopeia}.pks), s)$.
Without knowledge of $s$, an adverasial dealer cannot use the same value ciphertext $c$ with another instance $x'$.

\begin{algorithm}
    \caption{zkSNARK circuit}
    \label{alg:snark_circuit}
    \begin{algorithmic}[1]
        \Require $x_C = (c, \mathcal{R}, x, y, pks)$, $w_C = s$
        \State $y' \gets H(s \concat c \concat \mathcal{R}, x)$
        \State $c' \gets \textsf{PVSS.genDist}(s, pks)$
        \State \Return $y' = y \land c' = c$
    \end{algorithmic}
\end{algorithm}

When the dealer calls the smart contract function \textsf{Cassiopeia.encrypt}, he must include $y$ and $\pi$.
Then, the contract verifies that the proof $\pi$ is valid, as well the PVSS distribution as outlined above.
Concretely, the proof must be valid according to $V(\tau, (c, \mathcal{R}, x, y, \textsf{Cassiopeia}.pks), \pi) = 1$.
The Cassiopeia smart contract is written in pseudocode below.

\begin{algorithm}[H]
\caption{Cassiopeia Smart Contract}
\label{cassiopeia_no_incentives}
    \begin{algorithmic}[1]
        \Contract{Cassiopeia}
            \Let{n, t, pks}{\bot}
            \Let{C, S, M}{\emptyset}
            
            \Function{\sf constructor}{$\overline{n}, \overline{t}, \overline{pks}$}
                \Let{(n, t, pks)}{(\overline{n}, \overline{t}, \overline{pks})}
            \EndFunction
            
            \Function{\sf encrypt}{$c, \mathcal{R}, x, y, \pi$}
                \State $(\hat{s}, \pi_D) \gets c$
                \State require($V(\tau, (c, \mathcal{R}, x, y, pks), \pi) = 1 \land \textsf{PVSS.verifyDist}(\hat{s}, \pi_D, pks)$)
                \State $id \gets H(c, \mathcal{R}, x)$
                \State $C_{id} \gets (c, \mathcal{R}, x)$
                \State \Return $id$
            \EndFunction
            
            \Function{\sf claim}{$id, w$}
                \State $\{\mathcal{R}, x, \dots\} \gets C_{id}$
                \State require($(x, w) \in \mathcal{R}$)
                \State $M_{id} \gets \textsc{claimed}$
            \EndFunction
            
            \Function{\sf submitShare}{$s_i', \pi_i, id, i$}
                \State require($M_{id} = \textsc{claimed}$)
                \State $(\hat{s}, \bot) \gets C_{id}.c$
                \State $\textsf{PVSS.verifyShare}(i, \hat{s}_i, s_i', \pi_i)$
                \State $S_{id,i} \gets s$
            \EndFunction
        \EndContract
    \end{algorithmic}
\end{algorithm}
